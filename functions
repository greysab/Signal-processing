def SNR(signal,peak):
    peaks = peak[signal[peak]<np.max(signal)/6]
    noise=np.mean(signal[peaks])
    return np.max(signal)/noise

def Width(smoke,xx,noise):
	half=(np.max(smoke)-noise)/2+noise
	#find smoke half amplitude points
	id_half=array(np.where(abs(smoke-half)<0.0002))[0]  
	#consider only point close to the smoke peak
	first=array(np.where(smoke==np.max(smoke)))[0] 
	if first>id_half[0]+100:
		d=find_nearest(id_half,first)
		ind=id_half[d-1:]
	# if no points match try a greater value
	if len(ind)==0 or len(ind)==1 or abs(np.mean(ind)-ind[0])<2:
		ind=array(np.where(abs(smoke-half)<0.0004))[0]	
	#if severals peaks in the smoke consider the mean width
	if len(ind)>10:
		sup=np.mean(ind)
	else:
		sup=ind[len(ind)-1]
	width=sup-ind[0]
	#indices used in pvn 
	return sup,ind[0]

def pvn(smoke,sup,inf,h): #h : smoke amplitude (considering noise)
	inf=int(inf)
	sup=int(sup)
	#detect peaks and valley within the smoke width+100 deviation
	peak=detect_peaks(smoke[inf:sup+100], show=False,valley=False)
	valley=detect_peaks(smoke[inf:sup+100], show=False,valley=True)
	#match number of peaks and valley
	p=len(peak)
	v=len(valley)
	d=p-v
	if d>0:
		peak=peak[:-d]
	if d<0:
		valley=valley[:-d]
	#rescale indices
	peak=peak+inf
	valley=valley+inf
	#normalized peak/valley ratio
	pvn=smoke[peak]-smoke[valley]
	if len(pvn)==0:
		return 0
	return np.mean(pvn)/h

def Raise_time(segment,peak,valley):
    indP=peak[np.argsort(segment[peak])][::-1][0]
    indV=np.max(valley[valley<indP])
    return(indP-indV)
